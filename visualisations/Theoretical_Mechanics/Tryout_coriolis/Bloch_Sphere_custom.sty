%% == LaTeX PACKAGE blochsphere (customised) ===============================
%% 
%% 
%% Simon Verbruggen, Ghent University, Honorsprogram visualisations in maths and physics
%% Aug 13, 2025
%% https://ugent-visualisations-maths-and-physics.github.io/

%% == REQUIRED PACKAGES =======================================================

% declare layers
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\RequirePackage{tikz}
\RequirePackage{tikz-3dplot}
\RequirePackage{tikz-3dplot-circleofsphere}
\RequirePackage{xcolor}

% ket command for easy notation
\newcommand{\ket}[1]{\left| #1 \right>}

%% == TikZ STYLES =============================================================

% make sure points (via tikz-3dplot-circleofsphere) have no marker/text in them
\renewcommand{\tdplotCsFrontsidePoint}{}
\renewcommand{\tdtlotCsBacksidePoint}{}



% on layer allows us to choose which layer we draw on via a style
\tikzset{
  on layer/.code={
    \pgfonlayer{#1}\begingroup
    \aftergroup\endpgfonlayer
    \aftergroup\endgroup
  }}

\pgfmathsetmacro{\CircleSize}{0.08}     % radius of coordinate circles/dots
% define some custom styles
\tikzset{arrowstyle/.style={->,>=stealth},
    SphereLine/.style={ultra thick},
    HelpLine/.style={semithick},
    AxisLine/.style={thick},
    Mainline/.style={very thick},
    SmallTextFont/.style={font=\normalsize},
    LargeTextFont/.style={font=\large},
    CircleNodeStyle/.style={draw=black, thick, shape=circle, fill=white, minimum size=\CircleSize*2 cm, inner sep=0pt}}

% define styles for the functions used here
\tikzset{tdplotPtFrontOrig/.style={CircleNodeStyle},
        tdplotPtBackOrig/.style={CircleNodeStyle, on layer=background},
        StateNodeOrig/.style={LargeTextFont, above right},
        tdplotPtFront/.style={tdplotPtFrontOrig},
        dplotPtBack/.style={tdplotPtBackOrig},
        StateNode/.style={StateNodeOrig}}

\tikzset{tdplotCsFront/.style={HelpLine, solid},
        tdplotCsBack/.style={HelpLine, dashed, on layer=background},
        ArcNodeStyle/.style={font=\scriptsize, above right}}


%% == COMMANDS ================================================================

\newcommand{\DrawBlochSphere}[1]{
%   Draw a bloch sphere along with an axis system and the north and sout pole.
% 
%   Input:
%   #1 - radius of sphere

% parse input
\pgfmathsetmacro{\r}{#1} 

%set orientation of the bloch axis system
\pgfmathsetmacro{\AxisPhiRotation}{25}
\tdplotsetmaincoords{70}{90+\AxisPhiRotation}

\begin{scope}[tdplot_main_coords]   
    % define coordinates for the exit points of the arrows
    \tdplotsetcoord{Xexit}{\r}{90}{0}
    \tdplotsetcoord{Yexit}{\r}{90}{90}
    \tdplotsetcoord{Zexit}{\r}{90}{90}

    % AXES
    \begin{pgfonlayer}{background}
        % draw z-axis downward
        \draw[thin] (0,0,-\r) -- (0,0,0); 
        
        \begin{scope}[AxisLine]
            % draw the arrows (inside the sphere)
            \draw (0,0,0) -- (1.0*\r,0,0); 
            \draw (0,0,0) -- (0,1.0*\r,0);
            \draw (0,0,-\r) -- (0,0,1.30*\r);
        \end{scope}
    \end{pgfonlayer}

    % define origin coordinate
    \coordinate (O) at (0,0,0);

    % fill the sphere
    \draw[tdplot_screen_coords,fill=blue!40, opacity=0.40] (0,0,0) circle (\r);
    \begin{pgfonlayer}{foreground}
        % draw the outline of the sphere
        \draw[tdplot_screen_coords, draw=black, SphereLine] (0,0,0) circle (\r);
        
        % draw arrows, outside the sphere
        \begin{scope}[AxisLine, SmallTextFont]
            \draw[arrowstyle] (\r,0,0) -- (1.3*\r,0,0) node[anchor=north east] {$x$}; 
            \draw[arrowstyle] (0,\r,0) -- (0,1.3*\r,0) node[anchor=west] {$y$};
            \draw[arrowstyle] (0,0,\r) -- (0,0,1.3*\r) node[anchor=south] {$z$};
        \end{scope}
    \end{pgfonlayer}

     % draw great circle xy-plane
    \begin{scope}[HelpLine]
        \tdplotCsDrawLatCircle{\r}{0}
    \end{scope}

    % define the ground (|0>) and exited state (|1>)
    \tdplotsetcoord{GroundState}{\r}{180}{0}
    \tdplotsetcoord{ExcitedState}{\r}{0}{0}

    % reset TikZ styles for points
    \tikzset{tdplotPtFront/.style={tdplotPtFrontOrig}}
    \tikzset{tdplotPtBack/.style={tdplotPtBackOrig, fill=blue}}
    \tikzset{StateNode/.style={StateNodeOrig}}
    \tikzset{StateNode/.style={StateNodeOrig}}
\end{scope}

}

\newcommand{\DrawFullStateVector}[3]{
    % Draws state vector on the sphere, along with its projection onto the xy-plane.
    % 
    % Input:
    %   #1 - Polar angle (theta)
    %   #2 - Azimuthal angle (phi)
    %   #3 - label position

    % parse input
    \pgfmathsetmacro{\thetavec}{#1}
    \pgfmathsetmacro{\phivec}{#2}

    % size of angle indicators (as ratio of state vector size)
    \pgfmathsetmacro{\RatioAngle}{0.4}

    \begin{scope}[tdplot_main_coords]
        % Compute the vector (state), on the sphere
        \tdplotsetcoord{PsiVector}{\r}{\thetavec}{\phivec}
        % define shorter vector such that arrow stops before the actual state
        \pgfmathsetmacro{\rshort}{(\r - \CircleSize*2)}  
        \tdplotsetcoord{PsiVectorShort}{\rshort}{\thetavec}{\phivec}

        % draw state vector
        \draw[arrowstyle, Mainline] (O) -- (PsiVectorShort);

        % draw the projections of the state vector
        % define projection of point onto xy-plane
        \pgfmathsetmacro{\LengthShortPsi}{\r * sin(\thetavec)} 
        \tdplotsetcoord{PsiVectorProj}{\LengthShortPsi}{90}{\phivec}    
        % draw the projected line and the projection line
        \draw[thin, dashed] (PsiVectorProj) -- (O);                 
        \draw[thin, dashed] (PsiVectorProj) -- (PsiVector);

        % draw state
        \DrawState{#1}{#2}{#3}
        
        \begin{scope}[SmallTextFont]
            % draw the spherical angles next to the vector
            % phi angle
            \tdplotdrawarc{(O)}{\r*\RatioAngle}{0}{\phivec}{anchor=north}{$\varphi$}
            % draw arc on the circle:
            % theta angle
            \tdplotsetthetaplanecoords{\phivec} % set plane along the phi angle
            \tdplotdrawarc[tdplot_rotated_coords]{(0,0,0)}{\r*\RatioAngle}{0}{\thetavec}{anchor=south}{$\theta$}
        \end{scope}

        
    \end{scope}
}

\newcommand{\DrawState}[3]{
    % Draws state point on the sphere
    % 
    % Input:
    %   #1 - Polar angle (theta)
    %   #2 - Azimuthal angle (phi)
    %   #3 - label text

    % parse input
    \pgfmathsetmacro{\thetavec}{#1}
    \pgfmathsetmacro{\phivec}{#2}

    

    \begin{scope}[tdplot_main_coords]
        \tdplotsetcoord{State}{\r}{\thetavec}{\phivec}
        \tdplotCsDrawPoint{\r}{\phivec}{\thetavec}
        \node[StateNode] at (State) {#3};
    \end{scope}
}


\newcommand{\xyPlaneRotationWrapper}[5][]{
    % adjust the styles for the arcs (e.g. color)
    \tikzset{tdplotCsFront/.append style={#1}}
    \tikzset{tdplotCsBack/.append style={#1}}
    \tikzset{tdplotCsFrontArc/.append style={#1}}
    \tikzset{tdplotCsBackArc/.append style={#1}}

    % parse inputs
    \pgfmathsetmacro{\ThetaVecBegin}{#2}
    \pgfmathsetmacro{\ThetaVecEnd}{#3}
    \pgfmathsetmacro{\PhiVec}{#4}

    % convert coordinates to rotated frame
    \pgfmathsetmacro{\phiVecCs}{\PhiVec - 90}
    \pgfmathsetmacro{\ThetaVecBeginCs}{180-\ThetaVecBegin}
    \pgfmathsetmacro{\ThetaVecEndCs}{180-(\ThetaVecEnd-2)}

    \begin{scope}[tdplot_main_coords]
        % draw the circle which represents the rotation line
        \tdplotCsDrawCircle{\r}{\phiVecCs}{90}{0} 
        % draw the actual arc
        \tdplotCsDrawArc{\r}{\phiVecCs}{90}{0}{\ThetaVecBeginCs}{\ThetaVecEndCs}

        % draw node midway the arc
        \pgfmathsetmacro{\MidThetaAngle}{(\ThetaVecBegin + \ThetaVecEnd)/2}
        \tdplotsetcoord{MidArc}{\r}{\MidThetaAngle}{\PhiVec}
        \node[ArcNodeStyle] at (MidArc) {#5};
    \end{scope}
}

\newcommand{\zRotationWrapper}[5][]{
    % adjust the styles for the arcs (e.g. color)
    \tikzset{tdplotCsFront/.append style={#1}}
    \tikzset{tdplotCsBack/.append style={#1}}
    \tikzset{tdplotCsFrontArc/.append style={#1}}
    \tikzset{tdplotCsBackArc/.append style={#1}}

    % parse inputs
    \pgfmathsetmacro{\ThetaVec}{#2}
    \pgfmathsetmacro{\PhiVecBegin}{#3}
    \pgfmathsetmacro{\PhiVecEnd}{#4}

    \begin{scope}[tdplot_main_coords]
        % draw the circle which represents the rotation line
        \tdplotCsDrawCircle{\r}{0}{0}{90 - \ThetaVec} 
        % draw the actual arc
        \tdplotCsDrawArc{\r}{0}{0}{90 - \ThetaVec}{\PhiVecBegin}{\PhiVecEnd}

        % draw node midway the arc
        \pgfmathsetmacro{\MidPhiAngle}{(\PhiVecBegin + \PhiVecEnd)/2}
        \tdplotsetcoord{MidArc}{\r}{\ThetaVec}{\MidPhiAngle}
        \node[ArcNodeStyle] at (MidArc) {#5};
    \end{scope}
}

% ------------------------------------------------------------------------------

% set styles for the used arrows and arcs
\tikzset{tdplotCsFrontArc/.style={SphereLine},
        tdplotCsBackArc/.style={SphereLine, dashed,  on layer=background},
        tdplotCsDrawArrow/.style={arrowstyle}}

\newcommand{\tdplotCsDrawArc}[7][]{%
  % Draws a circle of a sphere.
  % 
  % Input:
  %   #1 - TikZ style
  %        - use tdplotCsFront/.style={...} to style the front side arc
  %        - use tdplotCsBack/.style={...} to style the back side arc
  %        - use tdplotCsFill/.style={...} to style the circle filling
  %        - use tdplotCsDrawArrow/.style={...} to style the arrow
  %        - use tdplotCsDrawAux to draw some auxiliary information
  %        
  %   #2 - Radius of sphere
  %   #3 - Azimuthal angle of drawing plane 1)
  %   #4 - Polar angle of drawing plane 2)
  %   #5 - Elevation angle of circle above the drawing plane. Permissible 
  %        values are -90 < #5 < 90. Use 0 for drawing a great circle.
  %   #6 - begin angle arc (on the circle)
  %   #7 - end angle arc (on the circle)
  % Ouput:
  %   none
  %
  % Footnotes:
  %   1) passed as alpha to \tdplotsetrotatedcoords{alpha}{beta}{gamma}
  %   2) passed as beta to \tdplotsetrotatedcoords{alpha}{beta}{gamma}
  \begin{scope}[#1]                                                             % Macro scope >>
    % Do some computation                                                       #   -----------------------------------
    \pgfmathsetmacro\r  {#2}                                                    %   Parse radius
    \pgfmathsetmacro\alp{#3}                                                    %   Parse azimuthal angle (alpha)
    \pgfmathsetmacro\bet{#4}                                                    %   Parse polar angle (beta)
    \pgfmathsetmacro\eps{#5}                                                    %   Parse elevation angle (epsilon)
    \pgfmathsetmacro\bet{#4}                                                    %   Parse polar angle (beta)
    \pgfmathsetmacro\eps{#5}                                                    %   Parse elevation angle (epsilon)
    \pgfmathsetmacro{\phiStart}{#6}                                             %   Parse begin angle arc
    \pgfmathsetmacro{\phiEnd}{#7}                                               %   Parse end angle arc
    \pgfmathsetmacro\re {\r*cos(\eps)}                                          %   Radius of circle
    \pgfmathsetmacro\ze {\r*sin(\eps)}                                          %   z-coordinate of drawing plane
    \pgfmathsetmacro\coX{\ze*cos(\alp)*sin(\bet)}                               %   x-coordinate offset for ze
    \pgfmathsetmacro\coY{\ze*sin(\alp)*sin(\bet)}                               %   y-coordinate offset for ze
    \pgfmathsetmacro\coZ{\ze*cos(\bet)}                                         %   z-coordinate offset for ze
    \coordinate (coffs) at (\coX,\coY,\coZ);                                    %   Offset as coordinate value
    % Rotate and offset coordinate system                                       %   -----------------------------------
    \tdplotsetrotatedcoords{\alp}{\bet}{0}                                      %   Rotate coordinate system
    \tdplotsetrotatedcoordsorigin{(coffs)}                                      %   Offset coordinate system
    % Draw                                                                      %   -----------------------------------
    \begin{scope}[tdplot_rotated_coords]                                        %   Drawing scope >>
      \tdplotCsComputeTransformRotScreen                                        %     Compute full rotation matrix
      \pgfmathsetmacro\tanEps{tan(\eps)}                                        %     Tangent of elevation angle
        \pgfmathsetmacro\u{\azy}                                                %       Substitution u=...
        \pgfmathsetmacro\v{sqrt( (\azx)^2 + (\azy)^2 - (\azz)^2*(\tanEps)^2 )}  %       Substitution v=...
        \pgfmathsetmacro\w{\azx - \azz*\tanEps}                                 %       Substitution w=...
        \pgfmathsetmacro\phiBf{2*atan2(\u-\v,\w)}                               %       Back->front crossing angle
        \pgfmathsetmacro\phiFb{2*atan2(\u+\v,\w)}                               %       Front->back crossing angle
        \pgfmathsetmacro\bUnwrapA{(\phiFb-\phiBf)>360}                          %       Unwrap front->back angle #1?
        \pgfmathsetmacro\bUnwrapB{\phiBf>\phiFb}                                %       Unwrap front->back angle #2?
        \ifthenelse{\bUnwrapA=1}{\pgfmathsetmacro\phiBf{\phiBf+360}}{}          %       Unwrap front->back angle #1
        \ifthenelse{\bUnwrapB=1}{\pgfmathsetmacro\phiBf{\phiBf-360}}{}          %       Unwrap front->back angle #2
                                                                                %       \phiBf is now always smaller than \phiFb

        \pgfmathsetmacro{\minAngle}{min(\phiStart, \phiEnd)}
        \pgfmathsetmacro{\maxAngle}{max(\phiStart, \phiEnd)}

        \DoubleCheckInRangeWrapper{\bothInRangeFront}{\phiStart}{\phiEnd}{\phiFb}{\phiBf}
        \DoubleCheckInRangeWrapper{\bothInRangeBack}{\phiStart}{\phiEnd}{\phiFb}{\phiBf + 360}
        \pgfmathsetmacro{\anyInRange}{(\bothInRangeFront==1) || (\bothInRangeBack==1)}
        \ifthenelse{\anyInRange=1}{
            \ifthenelse{\bothInRangeFront=1}{
                \draw[tdplotCsFrontArc, tdplotCsDrawArrow]  (\phiStart:\re) arc (\phiStart:\phiEnd:\re);
            }{
                \draw[tdplotCsBackArc, tdplotCsDrawArrow]  (\phiStart:\re) arc (\phiStart:\phiEnd:\re);
            }
        }{
        \CheckInRange{\bBfCrossing}{\phiBf}{\phiStart}{\phiEnd}                               %       check if we cross from Back to front
        \ifthenelse{\bBfCrossing=1}{
            \pgfmathsetmacro{\phiCrossing}{\phiBf}                                                  % store the crossing angle
            \pgfmathsetmacro{\bFirstAngle}{(\phiEnd>\phiStart)}                                                  % store the crossing angle
            \ifthenelse{\bFirstAngle=1}{
            \tikzset{tdplotCsFirst/.style={tdplotCsBackArc}, tdplotCsLast/.style={tdplotCsFrontArc, tdplotCsDrawArrow}}      % store styles accordingly
            }{
            \tikzset{tdplotCsFirst/.style={tdplotCsFrontArc}, tdplotCsLast/.style={tdplotCsBackArc, tdplotCsDrawArrow}}      % store styles accordingly
            }
        }{} 
        
        % same thing for back->front angle
        \CheckInRange{\bFbCrossing}{\phiFb}{\phiStart}{\phiEnd}                               %       check if we cross from front to back
        \ifthenelse{\bFbCrossing=1}{
            \pgfmathsetmacro{\phiCrossing}{\phiFb}
            \pgfmathsetmacro{\bFirstAngle}{(\phiEnd>\phiStart)}                                                  % store the crossing angle
            \ifthenelse{\bFirstAngle=1}{
                \tikzset{tdplotCsFirst/.style={tdplotCsFrontArc}, tdplotCsLast/.style={tdplotCsBackArc, tdplotCsDrawArrow}}
            }{
                \tikzset{tdplotCsFirst/.style={tdplotCsBackArc}, tdplotCsLast/.style={tdplotCsFrontArc, tdplotCsDrawArrow}}
            }
            
        }{}

        % draw the arc based on the stored styles
        \draw[tdplotCsFirst]  (\phiStart:\re) arc (\phiStart:\phiCrossing:\re);
        \draw[tdplotCsLast] (\phiCrossing:\re) arc (\phiCrossing:\phiEnd:\re);
        }

        
                                                                                %   -----------------------------------
        
        
    \end{scope}                                                                 %   << (Drawing scope)
  \end{scope}                                                                   % << (Macro scope)
}

\newcommand{\DoubleCheckInRangeWrapper}[5]{%

        % parse inputs
        \pgfmathsetmacro{\PhiCheckA}{#2}
        \pgfmathsetmacro{\PhiCheckB}{#3}
        \pgfmathsetmacro{\PhiIntervalA}{#4}
        \pgfmathsetmacro{\PhiIntervalB}{#5}
        \CheckInRange{\startInRange}{\PhiCheckA}{\PhiIntervalA}{\PhiIntervalB}
        \CheckInRange{\endInRange}{\PhiCheckB}{\PhiIntervalA}{\PhiIntervalB}
        \pgfmathsetmacro{#1}{(\startInRange==1) && (\endInRange==1)}
}

\newcommand{\CheckInRange}[4]{%
        % checks if an angle is inside an interval
        % #1 = output macro name
        % #2 = value to check
        % #3 = interval start
        % #4 = interval end
        % parse inputs
        \pgfmathsetmacro{\PhiCheck}{#2}
        \pgfmathsetmacro{\PhiIntervalA}{#3}
        \pgfmathsetmacro{\PhiIntervalB}{#4}
        % determine the min and max angles from the two angles
        \pgfmathsetmacro{\minAngle}{min(\PhiIntervalA, \PhiIntervalB)}
        \pgfmathsetmacro{\maxAngle}{max(\PhiIntervalA, \PhiIntervalB)}
    
        \pgfmathsetmacro{#1}{(\PhiCheck>\minAngle) && (\PhiCheck<\maxAngle)}
}